欢迎扫码添加公号「码海」，第一时间接收优质文章

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnl25mm851j30by0bydgo.jpg)

## 前言

红黑树是算法领域中一个著名的二叉查找树实现，它能够以较小的开销保持二叉查找树的平衡。具备平衡性质的二叉查找树能够极大地提高节点的查询速度。举个形象一点的例子：从一个十亿节点的红黑树中查找一个节点，所需要的查询次数不到30，这不禁让人感叹算法的魅力。

红黑树是工程中最常见的二叉查找树的实现，例如在Linux的内存管理和进程管理中就用到了红黑树；Java语言的集合包、C++语言的标准模板库中均提供了红黑树的实现类。

红黑树本身的设计很复杂，多数情况下我们也不需要自己去实现红黑树，但研究红黑树还是有意义的。一方面可以让学习者领略这种神奇的数据结构的奥妙，另一方面可以作为一种思维训练工具，提升自己的算法设计能力。

本文以漫画形式讲述红黑树，第一话讲解二叉查找树的概念和基本操作，包括节点查找、插入、删除；第二话讲解二叉查找树的缺点和红黑树的概念，以及红黑树的节点旋转操作；第三话讲解红黑树的节点插入操作；第四话讲解红黑树的节点删除操作；第五话和彩蛋部分讲解红黑树在插入修正和删除修正时，对各种CASE所进行的调整操作背后的思想。

红黑树的实现中，最难的部分在于实现节点的插入和删除时，要穷举所有可能的CASE，然后对每种CASE进行处理。在理解节点的插入和删除的过程时，读者要把握住一个中心：每种CASE所进行的调整步骤都在尽量恢复插入/删除节点后所违反的红黑树特性，如果当前CASE解决不了，就转成另一种更接近问题解决状态的CASE。每种CASE的所进行的调整步骤都是为了向解决问题的出口更靠近一步，直至找到出口。

漫画采用大量的图示来展示红黑树操作的诸多细节，作者力求详尽，因此篇幅略长。附录给出了完整的二叉查找树定义 + 测试代码，以及红黑树定义 + 测试代码。两份代码均经过了若干次十万数量级随机节点插入和删除测试，结果均无误。读者可贴到自己的 IDE 中，结合本文讲解进行调试研究。

在电脑端本文阅读效果更佳。另外，读者可联系「码海」公众号博主（微信：geekoftaste）获取本漫画的pdf版本。

## 正文

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b036df4f251d46b2a4b1ada2239d5a67~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b7f2b50b85464c93bae3f03d0ed074~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6368815cf4d04ab9a8aaeb256d0fe055~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eda0bcaa97404886aef58223232129d7~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bf39da4342d47479af48830b0f86537~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0fe545a8a14bdca794746c5a637951~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26adf501a94641c7a2cb7c8e29f9aa66~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad53c62f8f547b3af994eab6fbd576e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75f4a10ee461499185377eb6d5e1f1c2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/646a1bfcbfd547f6b3c6298d13309372~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d55e2c6715045a28394526f355db167~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d550efb7c9b46c1a3dea41be967744b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc53b2e37d3e4297b7700dd9cb082003~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42148def6be04a30840e6c42aa1e4d65~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e511b1fc5541e9942e4eee3431b4d9~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6340aef5d2a4d0c8efa12192e0e58b6~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d6aef35c6754c5680b48a381e9264ff~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ab52fd442604f5294722c60799f9ee2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0a5db32729641dbb80148628688504d~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c430f35543fd43fa88353d8ffb39a1cd~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032a83ad25414c4399ecb62b81c52c23~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/496439a548284b2e8f19c164a2ecd932~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faa41e7608a647fdb7b4fa64eb4cff6e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d297badfc95142cdbdc19fdc8d811ddc~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf5349306ba74a098fcf5fbf9442373a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6906b08c66c64d0b947c4a63bc6b1654~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/877043c1ee374003bc4cb5cfe6050102~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8611e78d4b34f5fa03faf6209934182~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca1a1267d46a409a9650aac6b223e44e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b06e0cf5500400090bb9ae3d6c96646~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc8523125bc348e0a1e695005c726698~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22af120be58a4f81a7adc1e7221575f8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac3e2dc71d44d48beb40b5e8eb3e1f2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e04bed3522c24ebcac8124a717d3fa5c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36f8641ac3d74fb4b237d04b0609b5f9~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7c0b89e9fca4b69bf756d22578f6ad2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8764a7b9e6054ab8bc46986e81608809~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/889d073c9f214cf5ad9fa8eb1e9a743f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4db519bc3e3e4188afabe03b53ac5a5b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed78bd7673474706a0cbd8cf011e169c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fb65acd1b5f47beb9342a6b48fd05a6~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddcd01643eb3463b89f77ffb4132f4d2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d59d6da03ba4e049f04e258a0f37de5~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b503ca901c6c460fa6010700d4b0e283~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236c75657154449791cadd0d7c85c79c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0491d6817e78429789987829762cc9fb~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b614b63abac4afaacf7801cd6bf6909~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13b50fec6f1542c79f9c9a916049e84e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e3fc16eaa342949301cf87a4128816~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94f45a7095d44418cbee54657eb42a1~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aea64db5e054d3d946b134dd3f88420~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8be4cdb668974734b718993a5ccb574e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b53cb3edfe40099d6264056ad8ad49~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/611de00c9628443a8a792c195e836d50~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6eb1c0e75c640d49bcf3a72d8a77f90~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2c218559a64de8a33e8dce98bff84d~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35235a0a3fe141078252d1ee295f084f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45163ccf0fd44dc7ad368d9416c3d9ee~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69bb53db347c4865b46611a249030084~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d9a7054130f4ddb92aa3ccd1657ef39~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a59baba32844f32b9848aa6dcca91a8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72274c3879e3407680b3c19e44867e80~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd4b0782880e4a59b1eb63ddedf1a1ac~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae89ebe8319c41ea9ab94285578e72f8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa78c657785a445e8c9fea8b0835ae4a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691d9d84413d49f58ce94b70ad52d488~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f5a3b26efb4ca2947d536f7daa4590~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8c9e7d8b7724cf6bf11bc3d41ccea6a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc70e4d5019e415eb15c3699f1a90438~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01998c854adb43c89605ecd1fc17f977~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c969bae4c34af4bb7eb9a8e090141b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa45ca57a0924c77824cdeeb6de74258~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34c77d55b4cc49de8b55a98612d6c5b6~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61c9124beeda4fd8a0abaa4df0d04612~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/722eab7f005b444b9b67f00a2f5764f4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb72f446ce134b86b40a33f0ba045c07~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e161fb7ab92947448e88ee07ce4527c4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac08858acd114cdbaad980bfa9d57cd2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/293a092f3cbc45d381cfe5ab6077cbcb~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8065398f160b4c5a8e65941cc8811041~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4353b0bb9f834f9489aa19bfb753596b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f2d6160c9f4fe9a5826178a452f4f0~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc287d72d1c40ef988110a1974a1d85~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837b8f8e5a2548c0b315bcf2f36d8ba1~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaf7589bd9af43e586f5335a861f6322~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bea7c3a289ef4bde8ac32a649c8f90b8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53f6f49e1623460d898b235f9f4c7b2f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49f6358a22b14ec0bf29dd815809a342~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da98a2033fc14e60b250a6b20a88e8b7~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d0b77191995424f818e54edc36cebd0~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d1d356152b4a46b69e69583ff074a5~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c53696e24c2946c987257718247915d6~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea7bdd0d9334d408ce1acc2f04841fa~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/235088bda998428e928ce56b19c04b3c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/645d2e70f97a4be7b48d0a658382d5e7~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7e9026199c94368a4f0b1e497ede56c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b45ae47311de48d0b29b051806428b80~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bff9da67fa0945229864f8dd094843b9~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9bbf0e71e75471d910e916f611e220b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb6d40bc255141f9b67bffe1b55e2f1e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d47ab18b6f0344b3ac8d254706a8f315~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fb1418ecc5546e180bb1591136f92d7~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/675ff5edc236405b948c97aa1704a876~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb502465ae7e4036a759ce3e69fe1361~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1240785a8e484a33865c57160e1edde1~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae00dd04ee6a4c66b6a28b9a64abe9e1~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf45ee6be1534ac48be7f05232691567~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb8c929529e6491cadb95c7eeb8edf5d~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1909d6815b7d430c8ae8d4cd8c668494~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/039e73bb8616433d8c8c94063be3abac~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/282ffb6a730a4e0fa1e25c7d19c6ad4d~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b60a5cdd38c3495fb275be97cee41f21~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1f1cfbd5fc141158273c373b295e278~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c94c66d67104be981ec72d66350eb56~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6deb57c42de240aaba5869d44beb6678~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/197db1af1a4146b4987b4e00543093e0~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a96f471fa404c7fb5342353ff64b451~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd1bf9687a0b4265a5d25bb334822b2d~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edd6929403ff4f24a27472f11a2b56a5~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/874471e492544791a96b20c432feec7f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94629e7b832a4e51b56143c2e28463cb~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7b3031fa7734a5c96879f937f44512f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4f982b70b1349a3b6bbbff284a5304b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b36d34549f9e49aeb185047ba471d97b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0371aea3c49e405cb801434560458f50~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e792cd4f75f40939c80f09c11ab0bb0~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d1bb9f28fa4f16bf76cb762461d639~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be2e7ea74e5944b9b035ae109b4332ab~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bcc50049a42410798ce8a211f59a64f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3833ba7c6fdc4d5595f8570d5eabcab8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c318cb486a41829ebd3843a7201372~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2754f990bbc84ed6b4fdda6df1392f66~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34857216d42949d1bb65ce588767dffe~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a21526f02cd946f8af8ebd8d7f419365~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/216c937b6b6445089364a12acf53a375~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/604f406b5d8f4bd38c4187d93e242814~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7b3f49ec67741c8b5f2765f0f350071~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/649614c666af4263afca728655a100a4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce12943da2754b4bbe264697a54622cd~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2959a681a91f4faebcfdcc1217f6dffa~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f47e6c84be343f28254c28aa258b056~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83df70c9e78a49698657806a891f4144~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c48947b15b64d3cae21dd6c0b6922f1~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da1aff774f134630a7919c4d63b87cf8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8630f3e446d34beeb8748e9ce3ecf531~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1514ebf39ba84e96bd4a14ae140d83d8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8469a7a88ab04f52a069b2aad7168bd5~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79a1c3756d3340bf9a3b870f33132193~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db1e16e3bd34d2aabf7fc46926fac64~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37be765166154a7e8db20dff5b05312b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8438fccfa574fd1bf8f318be5a2a0de~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13536ce0ec1d4775b13841495faff6c9~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d78fc0ae96b41fcab04b90f72406402~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb9c7c901bd41b5af3a526f00678183~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f72ae0999046ca97be83f37892442a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678e102d63a04691aee710c6403cb2cf~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ba40b31e9584a288727850bea381368~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2a9b3def0e7400fa5a87c4e633cd3fe~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a2a76ff81db49848cf7276593d0a173~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31a1f973f6254b82bc2586cb360ee698~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec3d236b66648fc8dc4962871f86a4f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/907e942ecaa346ed9563c2a79e7f9d7e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e004a952e4b1469f87a2e415e0710d4f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f9dac03d1c4feaa8993cd7055007f3~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90970421457c4a298b18984a13e5fd44~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c738665707c44eebf88d73a67fbbad6~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a3e69f3f0414c5fb46daab006a455e2~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5d47ebc21741588311a54778a2591b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51df347e51ad4d42882ea14cde58be07~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6053d989951a48a3b318ca0753bc4606~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e06939796b6b4c21860db0fc5a071410~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09d36c2b2d6b402b853273a9983b8298~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/960474ee1c7c4f8dae2a3d0b46cce0ed~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d4d72fb94ee4d7390b6ebbd07965042~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6991594a65114a35995cd7726f51260b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4adf7d16ec9f445ebd62fed10fa057cb~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31ec299a169f4e21b449294d45d4a3ad~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3706b23fe80647cb92738587305afe35~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f73aea22f6b4f2386878b77bc4eed83~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5bae3f83d3f449dac7e200a8e921c74~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05705afbc3f7442ba4dee117e82ea8c4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1275291143c742b8ac283ddf1f911185~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b5227dd65e94ba2a45518a955e33539~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ab1f23011434e4b9d7be6ffed3d13d5~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1001549b6f7a46c0967576afab873f24~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfa18835e05a4ad397c68208b33612fd~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ceaecdc7284c809ecad1adaac9cd54~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd7b96575b4640d4827f21c71160261f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1957ef4ffdfa47838fd08aba6fb254da~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e58fca5a5694ff68210867a87080d9f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb67a6a99c94673874bf01cc7c8d3bf~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a98b958dd7b43ccbcc46002db343404~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9727f59d7ce244b9be8673447b3dd393~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7587045b76ac4ab2998ead11245502ff~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22ffc7f2e4744151a02a73d65d8fbf61~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dad2f0cf1dd41e28f34cf6837b3de8a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4715b6342f654cd28d8a3f01825ff2c0~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/787007aa85974524895d9daebc0a6cbc~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecce786660d34bc8b50ddebbbeb94460~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40bef913656b4fe7bac77eadbd6d3404~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/252b5732bf6b40d9899e6c0d6f956bd4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6429d76a727427b9fff23d782ecab03~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3ec310d0a0b496f9c690d9db4b98a1f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578f91614693421b8637a6ddbde2fe88~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8f4307751ff4515a0a02226ebd0636c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/481fc0e1af07431ab7380f6a559c346f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e081ca7079fe4bb8a1c79303184b4207~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d021e3d49a914773bd9ef91046c49adc~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/614bcaa6edc94c67bfc570b4c8d60456~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d849ff56164391a9b6d6b1c47814c5~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f99a5fc55f014c739268f611b697954a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b7925fa2d334e74bca34b024d7c3b6b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eea4eaae1ec4447b98ca68962405305~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89df0877725344eda0a263938686f099~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e09bcc343a40418659eb83203b86c3~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f698cf5b6f430497a2743777d01f42~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7086aa4baaac410bbd8cb1113db83c51~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4633116fa102433db87cc5c19446ff21~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30b8f7498e194e6a83f17716b85d4b78~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b73afbe852504609b77db2ba31a4b145~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ebfd4c53dd14653ab2cc8817c08ecf1~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/239d3c8f785a4d98988f13cd44039aae~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a15f371f4b94f80b7cac9fef2c85b52~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16e1d920442247a0b332b690222164a0~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9c43ed27f494380a7ac477780e1f8ec~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d093e87a47bf43f49c3a34b9b3a32c81~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac2499095a74f768c22e28628c0be38~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfda3b650ca2487399b4b78d1316a792~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e8ca957c28849828885101aec41a93d~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fe950ea2f214db4b62c5b98aff203c4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db7c5f6efb944f3c834f89ec29c309ef~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d3ceac4110447ea4a204e8fa3e10ac~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b8806e67d9b43f7a268b0ef2cd1bbe3~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b20b0323fc44c269ad53dda5d7a49a4~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3dbb6c435b0492c89ca00e3af356a14~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1400004b712d46ed956ed6e1cf672935~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8bb570a9b624986a106b9264c431597~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48a08482db5e425c921522c7ed392b16~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf92f9dede34457b36afdc654a0114c~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a05c7bdd0d417db8b45f09710ca862~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b82ef99b7034da2951c3845aee9d572~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aba457a0aaa8409b858c52163edcda7b~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d47ea6f0df1c47b78a05dc611945400a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/643d5c4b10214edaa681649ea7f69769~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45bfec08dca40e3ab571add230d07ca~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/219465e6f1074e709a97fc34a3cd2f9e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10f8430264ea45288bf6dda9f3dc5c3a~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e382c5289e4e483f98c449e0f15b05ae~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d0de01843634e04aec31e13bb5855a9~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742cf0fb0cd3446983b97faf7c39cfad~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14de3fb81da4434cb30ea1f279420484~tplv-k3u1fbpfcp-zoom-1.image)

欢迎扫码添加公号「码海」，第一时间接收优质文章

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnl25mm851j30by0bydgo.jpg)

## 附录：代码清单

### 二叉查找树代码

#### BsTreeTest.java

```java
package bst;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

public class BsTreeTest {
    public static void main(String[] args) {

        // 随机数的上限
        int bound = 10000000;

        // 随机序列的长度
        int seqLen = 100000;

        // 随机数生成器
        Random random = new Random();

        // 根节点值
        int rootValue = random.nextInt(bound);

        // 随机序列容器
        List<Integer> intSeq = new ArrayList<>();
        intSeq.add(rootValue);

        // 往随机序列容器中添加随机值
        while (intSeq.size() < seqLen) {
            int rand = random.nextInt(bound);
            intSeq.add(rand);
        }

        System.out.println("插入序列：" + intSeq);

        // 创建一个bst
        BsTree<Integer> bsTree = new BsTree<>();
        BsTreeNode<Integer> root = new BsTreeNode<>(rootValue);

        // 把intSeq中的随机数全部插入进去，测试节点插入过程
        for (Integer key : intSeq) {
            bsTree.insertRecursively(root, new BsTreeNode<Integer>(key));
        }

        // 插入完成后，打印整个bst的中序遍历结果，验证是否符合二叉搜索树的特性
        List<Integer> middleOderOutput1 = new LinkedList<>();
        bsTree.middleOder(root, middleOderOutput1);
        System.out.println("构造完成，中序遍历结果为：" + middleOderOutput1);
        System.out.println();

        // 选取一部分节点值，测试节点删除过程
        List<Integer> delList = middleOderOutput1.subList(middleOderOutput1.size() / 4, middleOderOutput1.size() / 2);

        for (int item : delList) {
            bsTree.deleteRecursively(root, item);
        }

        List<Integer> middleOderOutput2 = new LinkedList<>();
        bsTree.middleOder(root, middleOderOutput2);
        System.out.println("\n删除完成，中序遍历结果为：" + middleOderOutput2);
        System.out.println();

        // 测试bst中“删除前总节点数目 - 删除节点数目 = 删除后总节点数目”是否成立
        System.out.println("\n\n(out1.size()- out2.size()) == delList.size()? " + ((middleOderOutput1.size() - middleOderOutput2.size()) == delList.size()));
        // 测试bst中“删除前节点  包含全部  删除后节点”是否成立
        System.out.println("out1.containsAll(out2)? " + (middleOderOutput1.containsAll(middleOderOutput2)));
        // 测试bst中“删除前节点  包含全部  被删除节点”是否成立
        System.out.println("out1.containsAll(delList)? " + (middleOderOutput1.containsAll(delList)));
    }
}
```

#### BsTree.java

```java
package bst;

import java.util.Collection;

public class BsTree<T extends Comparable<T>> {

    /**
     * 使用递归实现 BsTree 查找
     *
     * @param root BST 根节点引用
     * @param key  待查找的节点值
     * @return 命中的节点
     */
    public BsTreeNode<T> searchRecursively(BsTreeNode<T> root, T key) {
        if (root == null) {
            return null;
        }

        if (root.nodeKey.compareTo(key) > 0) {
            return searchRecursively(root.left, key);
        } else if (root.nodeKey.compareTo(key) < 0) {
            return searchRecursively(root.right, key);
        } else {
            return root;
        }
    }

    /**
     * 中序遍历 BsTree，打印节点值（递归实现）
     *
     * @param root
     */
    public void inOder(BsTreeNode<T> root) {
        if (root == null) {
            return;
        }
        inOder(root.left);
        System.out.print("->" + root.nodeKey.toString());
        inOder(root.right);
    }

    /**
     * 中序遍历 BsTree，打印节点值（递归实现）
     *
     * @param root
     */
    public void middleOder(BsTreeNode<T> root, Collection<T> collection) {
        if (root == null) {
            return;
        }

        middleOder(root.left, collection);
        //System.out.print("->" + root.nodeKey.toString());
        collection.add(root.nodeKey);
        middleOder(root.right, collection);
    }

    /**
     * 向 BsTree 中插入节点（递归实现）
     * <p>
     * 二叉排序树本身是动态查找表的一种表示形式，有时会在
     * 查找过程中插入或者删除表中元素。当因为查找失败而需
     * 要插入数据元素时，该数据元素的插入位置一定位于二叉
     * 排序树的叶子结点，并且一定是查找失败时访问的最后一
     * 个结点的左孩子或者右孩子。
     *
     * @param root BsTree 根节点引用
     * @param key  待插入的节点值
     * @return 插入成功返回 true，如果树中有该元素不需要插入则返回 false
     */
    public boolean insertRecursively(BsTreeNode<T> root, T key) {
        if (root.nodeKey.compareTo(key) > 0) {
            if (root.left == null) {
                BsTreeNode<T> node = new BsTreeNode(key);
                root.left = node;
                node.parent = root;
                return true;
            } else {
                return insertRecursively(root.left, key);
            }
        } else if (root.nodeKey.compareTo(key) < 0) {
            if (root.right == null) {
                BsTreeNode<T> node = new BsTreeNode(key);
                root.right = node;
                node.parent = root;
                return true;
            } else {
                return insertRecursively(root.right, key);
            }
        } else {
            return false;
        }
    }

    /**
     * 向 BsTree 中插入节点（递归实现）
     * <p>
     * 二叉排序树本身是动态查找表的一种表示形式，有时会在
     * 查找过程中插入或者删除表中元素。当因为查找失败而需
     * 要插入数据元素时，该数据元素的插入位置一定位于二叉
     * 排序树的叶子结点，并且一定是查找失败时访问的最后一
     * 个结点的左孩子或者右孩子。
     *
     * @param root         BsTree 根节点引用
     * @param nodeInserted 待插入的节点值
     * @return 插入成功返回 true，如果树中有该元素不需要插入则返回 false
     */
    public boolean insertRecursively(BsTreeNode<T> root,
                                     BsTreeNode<T> nodeInserted) {
        if (root == null) {
            root = nodeInserted;
            return true;
        }

        if (root.nodeKey.compareTo(nodeInserted.nodeKey) > 0) {
            if (root.left == null) {
                root.left = nodeInserted;
                nodeInserted.parent = root;
                return true;
            } else {
                return insertRecursively(root.left, nodeInserted);
            }
        } else if (root.nodeKey.compareTo(nodeInserted.nodeKey) < 0) {
            if (root.right == null) {
                root.right = nodeInserted;
                nodeInserted.parent = root;
                return true;
            } else {
                return insertRecursively(root.right, nodeInserted);
            }
        } else {
            return false;
        }
    }


    /**
     * 假设要删除的为结点 p，则对于二叉排序树来说，需要根据结点 p
     * 所在不同的位置作不同的操作，有以下 3 种可能：
     * 1. 结点 p 为叶子结点，此时只需要删除该结点，并修改其双亲结点的指针即可
     * 2. 结点 p 只有左子树或者只有右子树，如果 p 是其双亲节点的左孩子，则直
     * ---接将 p 节点的左子树或右子树作为其双亲节点的左子树；反之也是如此，如
     * ---果 p 是其双亲节点的右孩子，则直接将 p 节点的左子树或右子树作为其双
     * ---亲节点的右子树；
     * 3. 结点 p 左右子树都有，此时有两种处理方式：
     * ---3.1. 令结点 p 的左子树为其双亲结点的左子树；结点 p 的右子树为其自
     * --------身直接前驱结点的右子树
     * ---3.2. 用结点 p 的直接前驱（或直接后继）来代替结点 p，同时在二叉排序
     * --------树中对其直接前驱（或直接后继）做删除操作（ps：这种方式更好，因
     * --------为这样可以最大程度的保证原树的结构，而且不会让树过于倾斜）
     */
    public void deleteRecursively(BsTreeNode<T> currentNode, T key) {
        if (currentNode == null) {
            return;
        }

        // 当前节点键值大于 key，去左子树寻找
        if (currentNode.nodeKey.compareTo(key) > 0) {
            deleteRecursively(currentNode.left, key);
        }
        // 当前节点键值小于 key，去右子树寻找
        else if (currentNode.nodeKey.compareTo(key) < 0) {
            deleteRecursively(currentNode.right, key);
        }
        // 当前节点键值等于 key，处理当前节点
        else {
            // 对于第一种情形，左右子树均为空，直接删掉就是了，不涉及树结构的调整
            if (currentNode.right == null && currentNode.left == null) {
                BsTreeNode<T> parent = currentNode.parent;

                // 通过父节点来删除节点
                if (parent.left == currentNode) {
                    parent.left = null;
                }
                if (parent.right == currentNode) {
                    parent.right = null;
                }

                System.out.print("\ncase1 delete: " + key);

                return;
            }
            // 对于第二种情形，待删除节点只有左子树，用待删除节点的左子树替换待删除节点即可
            else if (currentNode.right == null) {
                BsTreeNode<T> rootLeft = currentNode.left;
                T temp = rootLeft.nodeKey;
                currentNode.left = rootLeft.left;
                currentNode.right = rootLeft.right;
                currentNode.nodeKey = temp;

                // 修正parent引用
                if (currentNode.left != null) {
                    currentNode.left.parent = currentNode;
                }
                if (currentNode.right != null) {
                    currentNode.right.parent = currentNode;
                }
                System.out.print("\ncase2 delete: " + key);
            }
            // 对于第三种情形，待删除节点只有右子树，用待删除节点的右子树替换待删除节点即可
            else if (currentNode.left == null) {
                BsTreeNode<T> rootRight = currentNode.right;
                T temp = rootRight.nodeKey;
                currentNode.left = rootRight.left;
                currentNode.right = rootRight.right;
                currentNode.nodeKey = temp;

                // 修正parent引用
                if (currentNode.left != null) {
                    currentNode.left.parent = currentNode;
                }
                if (currentNode.right != null) {
                    currentNode.right.parent = currentNode;
                }
                System.out.print("\ncase3 delete: " + key);
            }

            /**
             * 第四种情形，左右子树都不为空，用待删除节点的直接前驱（或直接后继）
             * 来代替待删除节点，同时在二叉排序树中对其直接前驱（或直接后继）做
             * 删除操作
             */
            else {
                // 找到当前节点的的中序前驱节点
                BsTreeNode<T> node = currentNode.left;
                while (node.right != null) {
                    node = node.right;
                }

                // 节点内容替换
                currentNode.nodeKey = node.nodeKey;
                // 删除前驱节点
                deleteRecursively(node, node.nodeKey);

                System.out.print("\ncase4 delete: " + key);
            }
        }
    }


}


class BsTreeNode<T extends Comparable<T>> {
    /**
     * 关键字（键值）
     */
    T nodeKey;

    /**
     * 左节点引用
     */
    BsTreeNode<T> left;

    /**
     * 右节点引用
     */
    BsTreeNode<T> right;

    /**
     * 父节点引用，进行节点删除的时候会用到
     */
    BsTreeNode<T> parent;

    public BsTreeNode(T value) {
        this.nodeKey = value;
    }

    public BsTreeNode() {
    }

    @Override
    public String toString() {
        return nodeKey.toString();
    }
}
```

### 红黑树代码

#### RbTreeTest.java

```java
package rbt;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

public class RbTreeTest {

    public static void main(String[] args) {

        // 随机数的上限
        int bound = 1000000000;

        // 随机序列的长度
        int seqLen = 100000;

        // 随机数生成器
        Random random = new Random();

        // 根节点值
        int rootValue = random.nextInt(bound);

        // 随机序列容器
        List<Integer> intSeq = new ArrayList<>();
        intSeq.add(rootValue);

        // 往随机序列容器中添加随机值
        while (intSeq.size() < seqLen) {
            int rand = random.nextInt(bound);
            intSeq.add(rand);
        }

        System.out.println("压测开始，节点数量：" + seqLen);

        System.out.println("插入序列：" + intSeq);

        // 创建一个rbt
        RbTree<Integer> rbTree = new RbTree<>();

        // 把intSeq中的随机数全部插入进去，测试节点插入过程
        for (Integer key : intSeq) {
            rbTree.insert(key);
        }

        // 插入完成后，打印整个rbt的中序遍历结果，验证是否符合二叉搜索树的特性
        List<Integer> middleOderOutput1 = new LinkedList<>();
        rbTree.inOrder(middleOderOutput1);
        System.out.println("\n插入完成，中序遍历结果为：" + middleOderOutput1);
        System.out.println();

        // 打印整个rbt的形状
        rbTree.printTree();
        System.out.println();

        // 打印根节点到每个叶子节点的路径中，黑节点的数量，验证bst是否符合黑节点完美平衡特性
        List<RbTreeNode<Integer>> linkedList = new LinkedList<>();
        System.out.println();
        rbTree.printAllRootToLeafPaths(linkedList);
        System.out.println();

        // 选取一部分节点值，测试节点删除过程
        List<Integer> delList = middleOderOutput1.subList(middleOderOutput1.size() / 4, middleOderOutput1.size() / 2);
        System.out.println("\n删除序列：" + delList);

        for (Integer key : delList) {
            rbTree.remove(key);
        }

        List<Integer> middleOderOutput2 = new LinkedList<>();
        rbTree.inOrder(middleOderOutput2);
        System.out.println("\n删除完成，中序遍历结果为：" + middleOderOutput2);
        System.out.println();

        // 打印整个rbt的形状
        rbTree.printTree();
        System.out.println();

        // 打印根节点到每个叶子节点的路径中，黑节点的数量，验证bst是否符合黑节点完美平衡特性
        List<RbTreeNode<Integer>> linkedList2 = new LinkedList<>();
        System.out.println();
        rbTree.printAllRootToLeafPaths(linkedList2);
        System.out.println();

        // 测试rbt中“删除前总节点数目 - 删除节点数目 = 删除后总节点数目”是否成立
        System.out.println("\n(out1.size() - out2.size()) == delList.size()? " + ((middleOderOutput1.size() - middleOderOutput2.size()) == delList.size()));
        // 测试rbt中“删除前节点  包含全部  删除后节点”是否成立
        System.out.println("out1.containsAll(out2)? " + (middleOderOutput1.containsAll(middleOderOutput2)));
        // 测试rbt中“删除前节点  包含全部  被删除节点”是否成立
        System.out.println("out1.containsAll(delList)? " + (middleOderOutput1.containsAll(delList)));
    }
}
```

#### RbTree.java

```java
package rbt;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;


public class RbTree<T extends Comparable<T>> {

    /**
     * 根结点
     */
    private RbTreeNode<T> mRoot;
    private static final boolean RED = false;
    private static final boolean BLACK = true;

    public RbTree() {
        mRoot = null;
    }

    /**
     * 获取某个节点的父节点
     *
     * @param node
     * @return
     */
    private RbTreeNode<T> parentOf(RbTreeNode<T> node) {
        return node != null ? node.parent : null;
    }

    /**
     * 获取某个节点的颜色
     *
     * @param node
     * @return
     */
    private boolean colorOf(RbTreeNode<T> node) {
        return node != null ? node.color : BLACK;
    }

    /**
     * 判断某个节点是否为红色
     *
     * @param node
     * @return
     */
    private boolean isRed(RbTreeNode<T> node) {
        return ((node != null) && (node.color == RED)) ? true : false;
    }

    /**
     * 判断某个节点是否为黑色
     *
     * @param node
     * @return
     */
    private boolean isBlack(RbTreeNode<T> node) {
        return !isRed(node);
    }

    /**
     * 设置某个节点为黑色
     *
     * @param node
     */
    private void setBlack(RbTreeNode<T> node) {
        if (node != null) {
            node.color = BLACK;
        }
    }

    /**
     * 设置某个节点为红色
     *
     * @param node
     */
    private void setRed(RbTreeNode<T> node) {
        if (node != null) {
            node.color = RED;
        }
    }

    /**
     * 设置某个节点的父节点
     *
     * @param node
     * @param parent
     */
    private void setParent(RbTreeNode<T> node, RbTreeNode<T> parent) {
        if (node != null) {
            node.parent = parent;
        }
    }

    /**
     * 设置某个节点的颜色
     *
     * @param node
     * @param color
     */
    private void setColor(RbTreeNode<T> node, boolean color) {
        if (node != null) {
            node.color = color;
        }
    }

    public void preOrder() {
        preOrder(mRoot);
    }

    /**
     * 前序遍历红黑树
     *
     * @param tree
     */
    private void preOrder(RbTreeNode<T> tree) {
        if (tree != null) {
            System.out.print(tree.nodeKey + "->");
            preOrder(tree.left);
            preOrder(tree.right);
        }
    }


    /**
     * 中序遍历红黑树
     *
     * @param tree
     * @param collection 用于记录遍历的过程
     */
    private void inOrder(RbTreeNode<T> tree, Collection<T> collection) {
        if (tree != null) {
            inOrder(tree.left, collection);
            //System.out.print(tree.nodeKey + "->");
            collection.add(tree.nodeKey);

            // 用于验证节点是否符合“如果一个节点是红色的，则它的子节点必须是黑色的”
            if (tree.color == RED) {
                if (tree.left != null && tree.left.color == RED) {
                    System.out.print("\n该节点违反红黑树特性！！！\n");
                }
                if (tree.right != null && tree.right.color == RED) {
                    System.out.print("\n该节点违反红黑树特性！！！\n");
                }
            }

            inOrder(tree.right, collection);
        }
    }

    public void inOrder(Collection<T> collection) {
        inOrder(mRoot, collection);
    }

    /**
     * 后序遍历红黑树
     *
     * @param tree
     */
    private void postOrder(RbTreeNode<T> tree) {
        if (tree != null) {
            postOrder(tree.left);
            postOrder(tree.right);
            System.out.print(tree.nodeKey + "->");
        }
    }


    public void printAllRootToLeafPaths(List<RbTreeNode<T>> path) {
        printAllRootToLeafPaths(mRoot, path);
    }

    /**
     * 打印节点root到每个叶子节点（Nil）的路径上的黑节点个数
     *
     * @param root
     * @param path
     */
    public void printAllRootToLeafPaths(RbTreeNode<T> root, List<RbTreeNode<T>> path) {
        if (root == null) {
            return;
        }
        path.add(root);

        if (root.left == null && root.right == null) {
            path = path.stream().filter(e -> e.color).collect(Collectors.toList());
            //System.out.println("当前路径的黑节点数量：" + path.size());
            System.out.print("->" + path.size());
            return;
        } else {
            printAllRootToLeafPaths(root.left, new LinkedList<>(path));
            printAllRootToLeafPaths(root.right, new LinkedList<>(path));
        }
    }

    public void printTree() {
        printTree(mRoot);
    }

    /**
     * 打印红黑树每一层的节点，格式为：
     * 当前节点键值（当前节点的颜色  父节点键值  是父节点的左孩子还是右孩子）
     * 例如：1905(B 1971 L)
     *
     * @param root
     */
    public void printTree(RbTreeNode<T> root) {
        java.util.LinkedList<RbTreeNode<T>> queue = new java.util.LinkedList<RbTreeNode<T>>();
        java.util.LinkedList<RbTreeNode<T>> queue2 = new java.util.LinkedList<RbTreeNode<T>>();
        if (root == null) {
            return;
        }
        queue.add(root);
        boolean firstQueue = true;

        while (!queue.isEmpty() || !queue2.isEmpty()) {
            java.util.LinkedList<RbTreeNode<T>> q = firstQueue ? queue : queue2;
            RbTreeNode<T> n = q.poll();

            if (n != null) {
                String pos = n.parent == null ? "" : (n == n.parent.left
                        ? " L" : " R");
                String pstr = n.parent == null ? "" : n.parent.toString();
                String cstr = n.color ? "B" : "R";
                cstr = n.parent == null ? cstr : cstr + " ";
                System.out.print(n + "(" + (cstr) + pstr + (pos) + ")" + "\t");
                if (n.left != null) {
                    (firstQueue ? queue2 : queue).add(n.left);
                }
                if (n.right != null) {
                    (firstQueue ? queue2 : queue).add(n.right);
                }
            } else {
                System.out.println();
                firstQueue = !firstQueue;
            }
        }
    }


    /**
     * （递归实现）查找红黑树中键值为nodeKey的节点
     *
     * @param root
     * @param nodeKey
     * @return
     */
    private RbTreeNode<T> searchRecursively(RbTreeNode<T> root, T nodeKey) {
        if (root == null) {
            return root;
        }

        int cmp = nodeKey.compareTo(root.nodeKey);
        if (cmp < 0) {
            return searchRecursively(root.left, nodeKey);
        } else if (cmp > 0) {
            return searchRecursively(root.right, nodeKey);
        } else {
            return root;
        }
    }


    /**
     * 左旋：以某个结点P作为支点(旋转结点)，其右子结点V变为
     * 旋转结点P的父结点，右子结点V的左子结点R变为旋转结点
     * P的右子结点，左子结点F保持不变。
     *
     * @param pNode 支点(旋转结点)
     */
    private void leftRotate(RbTreeNode<T> pNode) {
        // P的右子结点V的左子结点R变为旋转结点P的右子结点
        RbTreeNode<T> vNode = pNode.right;
        RbTreeNode<T> rNode = vNode.left;
        pNode.right = rNode;

        // 修正R的parent为P
        if (rNode != null) {
            rNode.parent = pNode;
        }

        // 修正V的parent为P原来的parent
        vNode.parent = pNode.parent;

        if (pNode.parent == null) {
            // 如果P原来就没有parent，说明P原来就是根节点。现
            // 在V要变成P的parent，则新的根节点要更新为V
            this.mRoot = vNode;
        } else {
            // 如果P原来就有parent，则V取代P作为这个parent的左
            // 孩子或右孩子
            if (pNode.parent.left == pNode) {
                pNode.parent.left = vNode;
            } else {
                pNode.parent.right = vNode;
            }
        }

        // 旋转结点P变为结点V的左孩子
        vNode.left = pNode;
        // 结点V变为旋转结点P的父结点
        pNode.parent = vNode;
    }

    /**
     * 右旋：以某个结点P作为支点(旋转结点)，其左子结点F变为
     * 旋转结点P的父结点，左子结点F的右子结点K变为旋转结点
     * P的左子结点，右子结点V保持不变。
     *
     * @param pNode
     */
    private void rightRotate(RbTreeNode<T> pNode) {
        // P的左子结点F的右子结点K变为旋转结点P的左子结点
        RbTreeNode<T> fNode = pNode.left;
        RbTreeNode<T> kNode = fNode.right;
        pNode.left = kNode;

        // 修正K的parent为P
        if (kNode != null) {
            kNode.parent = pNode;
        }

        // 修正F的parent为P原来的parent
        fNode.parent = pNode.parent;

        if (pNode.parent == null) {
            // 如果P原来就没有parent，说明P原来就是根节点。现
            // 在F要变成P的parent，则新的根节点要更新为F
            this.mRoot = fNode;
        } else {
            // 如果P原来就有parent，则F取代P作为这个parent的左
            // 孩子或右孩子
            if (pNode == pNode.parent.right) {
                pNode.parent.right = fNode;
            } else {
                pNode.parent.left = fNode;
            }
        }

        // 旋转结点P变为结点F的右孩子
        fNode.right = pNode;
        // 结点F变为旋转结点P的父结点
        pNode.parent = fNode;
    }

    /**
     * 红黑树插入修正函数
     *
     * @param currentNode
     */
    private void insertFixUp(RbTreeNode<T> currentNode) {
        RbTreeNode<T> parent;
        RbTreeNode<T> gparent;

        // INSERT-FIXUP-CASE-3：当前节点的父节点存在，并且父节点的颜色是红色
        while (((parent = parentOf(currentNode)) != null) && isRed(parent)) {
            gparent = parentOf(parent);
            // 若当前节点的父节点是祖父节点的左孩子
            if (parent == gparent.left) {
                // INSERT-FIXUP-CASE-3.1：当前节点的叔叔节点是红色
                RbTreeNode<T> uncle = gparent.right;
                if ((uncle != null) && isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    currentNode = gparent;
                    continue;
                }
                // INSERT-FIXUP-CASE-3.2：当前节点的叔叔节点是黑色，且当前节点是右孩子
                if (parent.right == currentNode) {
                    RbTreeNode<T> tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = currentNode;
                    currentNode = tmp;
                }
                // INSERT-FIXUP-CASE-3.3：当前节点的叔叔节点是黑色，且当前节点是左孩子
                setBlack(parent);
                setRed(gparent);
                rightRotate(gparent);
            }
            // 若当前节点的父节点是祖父节点的右孩子
            else {
                // INSERT-FIXUP-CASE-3.1：当前节点的叔叔节点是红色
                RbTreeNode<T> uncle = gparent.left;
                if ((uncle != null) && isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    currentNode = gparent;
                    continue;
                }
                // INSERT-FIXUP-CASE-3.2：当前节点的叔叔节点是黑色，且当前节点是左孩子
                if (parent.left == currentNode) {
                    RbTreeNode<T> tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = currentNode;
                    currentNode = tmp;
                }
                // INSERT-FIXUP-CASE-3.3：当前节点的叔叔节点是黑色，且当前节点是右孩子
                setBlack(parent);
                setRed(gparent);
                leftRotate(gparent);
            }
        }

        // INSERT-FIXUP-CASE-1：被插入的节点是根节点，将根节点设为黑色
        if (currentNode == mRoot) {
            setBlack(this.mRoot);
            return;
        }
        // INSERT-FIXUP-CASE-2：被插入的节点的父节点是黑色，什么也不需要做
        if (parentOf(currentNode) != null && isBlack(parentOf(currentNode))) {
            // DO-NOTHONG
            return;
        }
    }

    /**
     * （递归实现）将结点插入到红黑树中
     *
     * @param root
     * @param nodeInserted
     * @return
     */
    public boolean insertRecursively(RbTreeNode<T> root,
                                     RbTreeNode<T> nodeInserted) {
        if (root == null) {
            mRoot = nodeInserted;
            return true;
        }

        if (root.nodeKey.compareTo(nodeInserted.nodeKey) > 0) {
            if (root.left == null) {
                // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中
                root.left = nodeInserted;
                nodeInserted.parent = root;
                // 2. 设置节点的颜色为红色
                nodeInserted.color = RED;
                // 3. 通过旋转和变色将它重新修正为一颗二叉查找树
                insertFixUp(nodeInserted);
                return true;
            } else {
                // 向左子树中递归操作
                return insertRecursively(root.left, nodeInserted);
            }
        } else if (root.nodeKey.compareTo(nodeInserted.nodeKey) < 0) {
            if (root.right == null) {
                // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中
                root.right = nodeInserted;
                nodeInserted.parent = root;
                // 2. 设置节点的颜色为红色
                nodeInserted.color = RED;
                // 3. 通过旋转和变色将它重新修正为一颗二叉查找树
                insertFixUp(nodeInserted);
                return true;
            } else {
                // 向右子树中递归操作
                return insertRecursively(root.right, nodeInserted);
            }
        } else {
            return false;
        }
    }

    /*
     * 新建结点(nodeKey)，并将其插入到红黑树中
     *
     * 参数说明：
     *     nodeKey 插入结点的键值
     */
    public void insert(T nodeKey) {
        RbTreeNode<T> node = new RbTreeNode<T>(nodeKey, BLACK, null, null, null);

        // 如果新建结点失败，则返回
        if (node != null) {
            insertRecursively(mRoot, node);
        }
    }


    /**
     * 红黑树删除修正函数
     * @param childOfNodeRemoved
     * @param parentOfNodeRemoved
     */
    private void removeFixUp(RbTreeNode<T> childOfNodeRemoved,
                             RbTreeNode<T> parentOfNodeRemoved) {
        // other是childOfNodeRemoved的兄弟节点
        RbTreeNode<T> other;

        // REMOVE-FIXUP-CASE-3: childOfNodeRemoved是“黑+黑”节点，
        // 且childOfNodeRemoved不是根
        while ((childOfNodeRemoved == null || isBlack(childOfNodeRemoved))
                && (childOfNodeRemoved != this.mRoot)) {
            if (parentOfNodeRemoved.left == childOfNodeRemoved) {
                other = parentOfNodeRemoved.right;
                if (isRed(other)) {
                    // REMOVE-FIXUP-CASE-3.1: childOfNodeRemoved的兄弟
                    // other是红色
                    setBlack(other);
                    setRed(parentOfNodeRemoved);
                    leftRotate(parentOfNodeRemoved);
                    other = parentOfNodeRemoved.right;
                }
                if ((other.left == null || isBlack(other.left)) &&
                        (other.right == null || isBlack(other.right))) {
                    // REMOVE-FIXUP-CASE-3.2: childOfNodeRemoved的兄弟
                    // other是黑色，且other的两个孩子也都是黑色
                    setRed(other);
                    childOfNodeRemoved = parentOfNodeRemoved;
                    parentOfNodeRemoved = parentOf(childOfNodeRemoved);
                } else {
                    if (other.right == null || isBlack(other.right)) {
                        // REMOVE-FIXUP-CASE-3.3: childOfNodeRemoved的兄弟
                        // other是黑色，并且other的左孩子是红色，右孩子是黑色
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other = parentOfNodeRemoved.right;
                    }
                    // REMOVE-FIXUP-CASE-3.4: childOfNodeRemoved的兄弟other
                    // 是黑色，并且other的右孩子是红色，左孩子是任意颜色
                    setColor(other, colorOf(parentOfNodeRemoved));
                    setBlack(parentOfNodeRemoved);
                    setBlack(other.right);
                    leftRotate(parentOfNodeRemoved);
                    childOfNodeRemoved = this.mRoot;
                    break;
                }
            } else {
                other = parentOfNodeRemoved.left;
                if (isRed(other)) {
                    // REMOVE-FIXUP-CASE-3.1: childOfNodeRemoved的兄弟
                    // other是红色
                    setBlack(other);
                    setRed(parentOfNodeRemoved);
                    rightRotate(parentOfNodeRemoved);
                    other = parentOfNodeRemoved.left;
                }
                if ((other.left == null || isBlack(other.left)) &&
                        (other.right == null || isBlack(other.right))) {
                    // REMOVE-FIXUP-CASE-3.2: childOfNodeRemoved的兄弟
                    // other是黑色，且other的两个孩子也都是黑色
                    setRed(other);
                    childOfNodeRemoved = parentOfNodeRemoved;
                    parentOfNodeRemoved = parentOf(childOfNodeRemoved);
                } else {
                    if (other.left == null || isBlack(other.left)) {
                        // REMOVE-FIXUP-CASE-3.3: childOfNodeRemoved的兄弟
                        // other是黑色，并且other的左孩子是红色，右孩子是黑色
                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other = parentOfNodeRemoved.left;
                    }
                    // REMOVE-FIXUP-CASE-3.4: childOfNodeRemoved的兄弟other
                    // 是黑色，并且other的右孩子是红色，左孩子是任意颜色
                    setColor(other, colorOf(parentOfNodeRemoved));
                    setBlack(parentOfNodeRemoved);
                    setBlack(other.left);
                    rightRotate(parentOfNodeRemoved);
                    childOfNodeRemoved = this.mRoot;
                    break;
                }
            }
        }

        //  REMOVE-FIXUP-CASE-1：childOfNodeRemoved是“红+黑”节点 ，
        // 直接把childOfNodeRemoved设为黑色
        if (childOfNodeRemoved != null && isRed(childOfNodeRemoved)) {
            setBlack(childOfNodeRemoved);
            return;
        }
        // REMOVE-FIXUP-CASE-2：childOfNodeRemoved是“黑+黑”节点，
        // 且childOfNodeRemoved是根，什么都不做
        if (childOfNodeRemoved != null && isBlack(childOfNodeRemoved)
                && childOfNodeRemoved == this.mRoot) {
            // DO-NOTHING
            return;
        }
    }

    /**
     * 删除结点
     *
     * @param nodeRemoved
     */
    private void remove(RbTreeNode<T> nodeRemoved) {
        // 被删除节点的左右孩子都不为空的情况
        if ((nodeRemoved.left != null) && (nodeRemoved.right != null)) {
            removeNodeWithDoubleChild(nodeRemoved);
        }
        // 被删除节点的左孩子不为空的情况
        else if (nodeRemoved.left != null) {
            removeNodeWithOnlyLeftChild(nodeRemoved);
        }
        // 被删除节点的右孩子不为空的情况
        else if (nodeRemoved.right != null) {
            removeNodeWithOnlyRightChild(nodeRemoved);
        }
        // 被删除节点的左右孩子都为空的情况
        else {
            removeNodeWithNoChild(nodeRemoved);
        }
    }

    /**
     * 被刪除节点的左右子树均不存在，直接删掉该节点即可
     *
     * @param nodeRemoved
     */
    private void removeNodeWithNoChild(RbTreeNode<T> nodeRemoved) {
        RbTreeNode<T> childOfNodeRemoved;
        RbTreeNode<T> parenOfNodeRemoved;
        boolean colorOfNodeRemoved;

        childOfNodeRemoved = null;
        parenOfNodeRemoved = nodeRemoved.parent;
        colorOfNodeRemoved = nodeRemoved.color;

        // 被删除节点不是根节点（根节点不存在父节点）
        if (parentOf(nodeRemoved) != null) {
            if (parentOf(nodeRemoved).left == nodeRemoved) {
                parentOf(nodeRemoved).left = childOfNodeRemoved;
            } else {
                parentOf(nodeRemoved).right = childOfNodeRemoved;
            }
        } else {
            // 被删除节点是根节点，更新根节点
            this.mRoot = childOfNodeRemoved;
        }

        // 刪除修正
        if (colorOfNodeRemoved == BLACK) {
            removeFixUp(childOfNodeRemoved, parenOfNodeRemoved);
        }

        return;
    }

    /**
     * 被删除节点只有右子树，用被删除节点的右子树替换被删除节点即可
     *
     * @param nodeRemoved
     */
    private void removeNodeWithOnlyRightChild(RbTreeNode<T> nodeRemoved) {
        RbTreeNode<T> childOfNodeRemoved;
        RbTreeNode<T> parenOfNodeRemoved;
        boolean colorOfNodeRemoved;

        childOfNodeRemoved = nodeRemoved.right;
        parenOfNodeRemoved = nodeRemoved.parent;
        colorOfNodeRemoved = nodeRemoved.color;

        childOfNodeRemoved.parent = parenOfNodeRemoved;

        // 被删除节点不是根节点（根节点不存在父节点）
        if (parentOf(nodeRemoved) != null) {
            if (parentOf(nodeRemoved).left == nodeRemoved) {
                parentOf(nodeRemoved).left = childOfNodeRemoved;
            } else {
                parentOf(nodeRemoved).right = childOfNodeRemoved;
            }
        } else {
            // 被删除节点是根节点，更新根节点
            this.mRoot = childOfNodeRemoved;
        }

        // 刪除修正
        if (colorOfNodeRemoved == BLACK) {
            removeFixUp(childOfNodeRemoved, parenOfNodeRemoved);
        }

        return;
    }

    /**
     * 被删除节点只有左子树，用被删除节点的左子树替换被删除节点即可
     *
     * @param nodeRemoved
     */
    private void removeNodeWithOnlyLeftChild(RbTreeNode<T> nodeRemoved) {
        RbTreeNode<T> childOfNodeRemoved;
        RbTreeNode<T> parenOfNodeRemoved;
        boolean colorOfNodeRemoved;

        childOfNodeRemoved = nodeRemoved.left;
        parenOfNodeRemoved = nodeRemoved.parent;
        colorOfNodeRemoved = nodeRemoved.color;

        childOfNodeRemoved.parent = parenOfNodeRemoved;

        // 被删除节点不是根节点（根节点不存在父节点）
        if (parentOf(nodeRemoved) != null) {
            if (parentOf(nodeRemoved).left == nodeRemoved) {
                parentOf(nodeRemoved).left = childOfNodeRemoved;
            } else {
                parentOf(nodeRemoved).right = childOfNodeRemoved;
            }
        } else {
            // 被删除节点是根节点，更新根节点
            this.mRoot = childOfNodeRemoved;
        }

        // 刪除修正
        if (colorOfNodeRemoved == BLACK) {
            removeFixUp(childOfNodeRemoved, parenOfNodeRemoved);
        }

        return;
    }

    /**
     * 被删除节点的左右孩子都不为空的情况，用被删除节点的直接前驱
     * （或直接后继）来代替被删除节点，同时在二叉排序树中对其直接
     * 前驱（或直接后继）做删除操作。这里针对后继节点进行操作。
     *
     * @param nodeRemoved
     */
    private void removeNodeWithDoubleChild(RbTreeNode<T> nodeRemoved) {
        // 找到当前节点的的中序后继节点，称为取代节点
        RbTreeNode<T> replace = nodeRemoved.right;
        while (replace.left != null) {
            replace = replace.left;
        }

        // 拷贝替代节点的内容到被删除节点（这里只拷贝nodeKey，实际上一个
        // 节点除了有nodeKey域，还有nodeData域，只不过我们简化了节点定
        // 义，拷贝过程应该连同nodeData一起拷贝）
        nodeRemoved.nodeKey = replace.nodeKey;
        // 然后删除替代节点
        remove(replace);
        return;
    }

    /**
     * 删除键值为nodeKey的结点
     *
     * @param nodeKey
     */
    public void remove(T nodeKey) {
        RbTreeNode<T> node;

        if ((node = searchRecursively(mRoot, nodeKey)) != null) {
            remove(node);
        }
    }

}


class RbTreeNode<T extends Comparable<T>> {
    /**
     * 颜色，黑-true / 红-false
     */
    boolean color;
    /**
     * 关键字（键值）
     */
    T nodeKey;
    /**
     * 左孩子
     */
    RbTreeNode<T> left;
    /**
     * 右孩子
     */
    RbTreeNode<T> right;
    /**
     * 父结点
     */
    RbTreeNode<T> parent;

    public RbTreeNode() {
    }

    public RbTreeNode(
            T nodeKey, boolean color, RbTreeNode<T> parent,
            RbTreeNode<T> left, RbTreeNode<T> right) {
        this.nodeKey = nodeKey;
        this.color = color;
        this.parent = parent;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return nodeKey.toString();
    }
}
```
